---
title: Analysis code used for the QSP NAFLD paper
output:
  pdf_document: default
  html_notebook: default
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

# Introduction
This code is the analysis portion of the paper. Intermediate data files are stored throughout the notebook as commented out `RDS` files. These are typically saved when creating the intermediate data is both/or time consuming or used at branch points within the analysis. Some of the code chunks rely on functions from my personal packages which are not on `CRAN` or `BioConductor` installed from github.

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```


## Installing my packages
```{r}

require(devtools)

# My package(s)
my_pkgs <- c("lefutils", "basicOmics")

if(!any(my_pkgs %in% row.names(installed.packages()))){
 devtools::install_github(paste0("lefeverde/", my_pkgs))
}

```
## Loading required packages
```{r}
require(tidyverse)
require(biomaRt)
require(matrixStats)
require(edgeR)
require(reshape2)
require(ggplot2)
require(lefutils)
require(basicOmics)
require(edgeR)
require(limma)
require(sva)
require(GSVA)
require(dendextend)

```



# Pre-processing pipeline
## Creating gene metadata
```{r}

gene_dir <- 'data-raw/DiStefano_raw_data/kallisto/'

# Getting ENS ids from 1st tsv
ens_trans <- 
  paste0(gene_dir, list.files(gene_dir)[[1]]) %>% 
  read_delim(., "\t") %>% 
  pull(target_id) %>% 
  str_split(., "\\.") %>% 
  map(1) %>% 
  unlist


attributes <- c("ensembl_gene_id", "ensembl_transcript_id")


ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", version=94)

tx2gene <-  getBM(attributes, "ensembl_transcript_id", ens_trans, ensembl)


attributes <- c("ensembl_gene_id",
                "external_gene_name",
                "gene_biotype",
                "description")

ens_genes <- unique(tx2gene$ensembl_gene_id)
gene_annots <- getBM(attributes, "ensembl_gene_id", ens_genes, ensembl)
#save(gene_annots, file = "gene_annots.RData")

```

## Identifying mis-labeled samples 
```{r}


sex_linked_genes <- c('ENSG00000131002', 'ENSG00000183878', 'ENSG00000067048')

txi_n192 <- readRDS('DiStefano_txi_and_p_192.rds')
p192 <- txi_n192[[1]]
txi_n192 <- txi_n192[[2]]
cnts <- txi_n192$counts
cnts_per_million <- cnts[rowMedians(cnts) > 1,] %>%
  data.frame(.) %>%
  cpm(., log = FALSE)

plot_data <- 
  data.frame(cnts_per_million[sex_linked_genes[1],], 
             sex=p192$sex, 
             sample_id=p192$dcl_patient_id) %>%
  melt(.) %>%
  dplyr::select( -one_of('variable')) %>%
  arrange(., value)

```


## Sex is incorrect for some samples 
Since this gene is Y-linked, I expect the males to have much higher expression than the females. I think the non-zero expression in the females can be attributed to multi-mapping reads. Kallisto does mapping a little differently, and so these are not discarded by default like with STAR and HISAT2.

```{r}
female_cutoff <-  plot_data %>%
  dplyr::filter(., sex =='Female') %>%
  arrange(., value) %>% 
  pull() %>% 
  quantile(., probs = .95) 

male_cutoff <-  plot_data %>%
  dplyr::filter(., sex =='Male') %>%
  arrange(., value) %>% 
  pull() %>% 
  quantile(., probs = .05)

suspicious_samples <- list(
  dplyr::filter(plot_data[plot_data$sex == 'Male',], value < male_cutoff),
  dplyr::filter(plot_data[plot_data$sex == 'Female',], value > female_cutoff) 
) %>% 
  lapply(., function(x){
    x$sample_id
  }) %>% 
  do.call(c, .)

```

## Creating new subsetted txi 
```{r}
suspicious_samples <- 
  c("DLDR_0189","DLDR_0031","DLDR_0022","DLDR_0017","DLDR_0131", "DLDR_0130","DLDR_0140","DLDR_0122","DLDR_0123","DLDR_0111")

load('data-raw/tx2gene.RData')
p192 <- readRDS('data-raw/DiStefano_raw_data/pdata.rds')
p <- p192 %>%
  dplyr::filter(., !dcl_patient_id %in% suspicious_samples)
row.names(p) <- p$dcl_patient_id

files <- 
  paste0(p$file_name, '.gz') %>% 
  paste0('data-raw/DiStefano_raw_data/kallisto/', .)
names(files) <- row.names(p)
txi <- tximport(files, type = 'kallisto', tx2gene = tx2gene, ignoreTxVersion = T, countsFromAbundance = 'lengthScaledTPM')
#saveRDS(list(p, txi), file='DiStefano_txi_and_p_182.rds')


```


# Preliminary data cleaning and analysis 


## Creating cleaned expression matrix object and running SVA
```{r}

load('data-raw/gene_annots.RData')
txi_list <- readRDS('DiStefano_txi_and_p_182.rds')
p <- txi_list[[1]]
txi <- txi_list[[2]]

mod <- basicOmics::better_model_matrix(~0 + diagnosis, data=p)
mod0 <- model.matrix(~1, data=p )
dge <- edgeR::DGEList(counts =  txi$counts, 
                      samples = p,
                      genes = gene_annots[row.names(txi$counts),])

dge <- dge[edgeR::filterByExpr(dge, group = dge$samples$diagnosis),]
dge <- dge[(rowSums(dge$counts > 1) >= .75*dim(dge)[2]),]
dge <- dge[!is.na(dge$genes$entrezgene),]

v <- voom(dge, mod, normalize.method = 'quantile')
svobj <- sva(v$E, mod=mod, mod0=mod0)
# saveRDS(list(v, svobj), 'data/DiStefano_diagnosis_n182_voom_qn_and_svobj.rds')

```


# GSVA pathway cluster analysis
## Loading KEGG metadata
These files are not going to be included because of licensing issues with KEGG. The MSigDB pathways can be found at this [link](https://software.broadinstitute.org/cancer/software/gsea/wiki/index.php/MSigDB_v7.0_Release_Notes).

```{r}

# This file might be able to be included
pth_data <- 
  read_rds('../reference_files/msigdb_v7.0/msigdb_v7.0_all_tibble.rds') %>% 
  filter(SUB_CATEGORY_CODE == "CP:KEGG") %>% 
  dplyr::select(STANDARD_NAME,EXACT_SOURCE) %>% 
  setNames(., c('name','id')) 

# I'm pretty sure this file won't be allowed at all (due to KEGG licensce)
hier_kegg <- 
  read_rds('../thesisAnalysis/data-raw/kegg_pathway_hierarchy.rds') %>% 
  left_join(pth_data, .) %>% 
  arrange(category_level_1)

# Same with this file but it can be obtained following the link provided above 
cp_kegg <- 
  '../reference_files/msigdb_v7.0/c2_kegg_entrez_msigdb_v7.0.gmt' %>% 
  clusterProfiler::read.gmt(.) %>% 
  filter(term %in% hier_kegg$name) %>% 
  split(., .$term) %>% 
  lapply(., function(x){
    x$gene
  })


kegg_annots <-  
  hier_kegg$category_level_1 %>% set_names(., hier_kegg$name)


```

## Loading and pre-processing gene expression data 
Since I'm going run GSVA, I'm removing the batch effects predicted by SVA instead of including them in the downstream deferentially enriched pathway analysis. This is because the SVA matrix will be the wrong size. I'm also uniquefying the genes by variance. In other words, of the genes which match to the same entrez gene ID, I'm choosing the one that has the most variance.

```{r}
load('data/gene_annots.RData')

v <-  read_rds('data/DiStefano_diagnosis_n182_voom_qn_and_svobj.rds')[[1]]
svobj <- read_rds('data/DiStefano_diagnosis_n182_voom_qn_and_svobj.rds')[[2]]
p <-  v$targets

e_rm <- 
  removeBatchEffect(v, covariates = svobj$sv, design = v$design)
e_rm <- 
  uniquefy_by_variance(e_rm, gene_annots, 'entrezgene') 
row.names(e_rm) <- gene_annots[row.names(e_rm),]$entrezgene



v_e <- uniquefy_by_variance(v$E, gene_annots, 'entrezgene')
row.names(v_e) <- gene_annots[row.names(v_e),]$entrezgene


```

## Running GSVA and Clustering the output
I'm converting the gene x patient expression matrix into a pathway x patient enrichment matrix via [GSVA](https://www.bioconductor.org/packages/release/bioc/html/GSVA.html). I then perform a clustering analysis on the pathway x patient enrichment matrix. 

```{r}

gsva_res_sva <- 
  gsva(e_rm, cp_kegg, method='gsva',  min.sz=1, max.sz=100000, parallel.sz=3)


tmp_data <- gsva_res_sva[names(kegg_annots),row.names(p)]

# Scaling row wise
tmp_data <-
  t(scale(t(tmp_data)))
tmp_data <- as.data.frame(tmp_data, check.names=FALSE)

col_clust <- 
  as.dist(1 - cor(tmp_data, method = 'pearson')) %>% 
  hclust(., "ward.D2")



```

### Showing a dendrogram of the results
This chunk just creates a dendrogram of the clustering, like the one in figure 2. First, I create a color map of the different diagnoses, then the actual plot itself

```{r}

library(RColorBrewer)
colours <- brewer.pal(n = 7, name = "Paired")

# Ok so creating the color map was a bit involved. I started with 
# a palette of discrete colors, 2 for each group (e.g., Fibrosis)
# and then interpolated them so that I had darker colors for the 
# advanced grade/stage within each group.

groups <-  
  p[,c('group', 'diagnosis')] %>% 
  distinct() %>%
  dplyr::slice(-1) %>% 
  arrange(diagnosis)

col_map <- 
  tibble(idx=sort(rep(1:3, 2)),colours=colours[1:6]) %>% 
  split(., .$idx) %>% 
  lapply(., function(x){
    x$colours
  })

col_map2 <- 
  lapply(seq_along(col_map), function(i){
    x <- unique(groups$group)[i]
    tmp_lvls <- groups %>% 
      filter(group==x) %>% 
      pull(diagnosis) %>% 
      droplevels %>% 
      as.character
    
    out_cols <- 
      colorRampPalette(col_map[[i]])(length(tmp_lvls)) %>% 
      setNames(., tmp_lvls)
  }) %>% do.call(c, .)

col_map <- 
  c(NORMAL=colours[length(colours)], col_map2) 

# Getting the diagnosis for the labels in the dendrogram 
ordered_colors <- annot_map$diagnosis[match(labels(col_clust), annot_map$sample_id)]
ordered_colors <- col_map[ordered_colors]

dend <- as.dendrogram(col_clust)
labels_colors(dend) <- ordered_colors

# Finally, the plot
par(cex=.5)
plot.new()
plot(dend)


```


## Creating new groups based on clustering
I'm cutting the dendogram at the 3rd level, since 3 distinct clusters naturally form (see figure 2 and previous section). This is used to create new groupings of the samples (see methods section of paper).

Apparently the default `cutree` will sort the clusters by number of items in each cluster. This is different than `ComplexHeatmap`. The `dendextend` version has an option to turn this "feature" off. To do this, set the confusingly named argument `order_clusters_as_data` to `FALSE`. 

```{r}

coefs_from_clusters <- 
  dendextend::cutree(col_clust, 3, order_clusters_as_data=FALSE) %>% 
  enframe %>% 
  as.data.frame %>% 
  setNames(., c('sample_id', "cluster_idx"))
coefs_from_clusters$cluster_idx <- paste0('c', coefs_from_clusters$cluster_idx)
coefs_from_clusters$cluster_idx <- 
  factor(coefs_from_clusters$cluster_idx, levels = unique(coefs_from_clusters$cluster_idx))
row.names(coefs_from_clusters) <- coefs_from_clusters$sample_id
coefs_from_clusters$sample_id <- NULL
lvls <- levels(coefs_from_clusters$cluster_idx)

```

## Running LIMMA-VOOM using the new groupings
### Identifying differentially enriched pathways 
```{r}

group_cont <- c("c2-c1", "c3-c1", "c3-c2")

mod <- 
  better_model_matrix(~0 + cluster_idx, data = coefs_from_clusters)

cont_mod <- 
  makeContrasts(contrasts = group_cont, levels=data.frame(mod, check.names = FALSE))

fit <-  t(scale(t(gsva_res_sva))) %>% # Row scaling
  lmFit(., data.frame(mod)) %>% 
  contrasts.fit(., cont_mod) %>% 
  eBayes


res <- get_limma_results(fit, group_cont)
names(res)[2] <- 'name'
res <- right_join( hier_kegg, res)

# saveRDS(res, 'lv_on_gsva_msig_kegg_pathways_from_row_scaled_clusters.rds')

```

### Identifying differentially expressed genes
```{r}
fit <-   
  lmFit(v, data.frame(mod)) %>% 
  contrasts.fit(., cont_mod) %>% 
  eBayes

res <- get_limma_results(fit, group_cont)
# saveRDS(res, "gene_res_from_clusters.rds")

```

# Creating gene signatures 
```{r}



```




